class Token:
  var type as primative
  var value as primative
  var line as primative
  var column as primative

define tokenize(source as primative) as list of Token:
  var tokens = []
  var i = 0
  while i < source.length:
    val ch = source[i]
    if ch.is_alpha():
      val ident = ch.consume_while(lambda c: c.is_alnum())
      tokens.append(Token.new("IDENT", ident, line, col))
    elif ch.is_digit():
      val num = ch.consume_while(lambda c: c.is_digit())
      tokens.append(Token.new("NUMBER", num, line, col))
    elif ch == "+":
      tokens.append(Token.new("PLUS", "+", line, col))
    # ... handle other symbols
    i += 1
  return tokens

class Node:
  var type as primative
  var children as list of Node
  var value as primative

define parse(tokens as list of Token) as AST:
  var ast = AST.new()
  while tokens.has_next():
    val token = tokens.peek()
    if token.type == "IDENT":
      val varname = tokens.consume()
      tokens.expect("EQUAL")
      val expr = parse_expression(tokens)
      ast.add(Node.new("VarDecl", [Node.new("Ident", [], varname), expr]))
    elif token.type == "NUMBER":
      ast.add(Node.new("ExprStmt", [Node.new("Literal", [], token.value)]))
    # ... handle other statements
  return ast

define resolve_scopes(ast as AST) as AST:
  var scope_stack = []
  for node in ast.nodes:
    if node.type == "VarDecl":
      scope_stack.push(node.children[0].value)
      node.children[0].scope = scope_stack.length
  return ast

define bind(ast as AST, table as SymbolTable) as AST:
  for node in ast.nodes:
    if node.type == "ExprStmt":
      val ident = node.children[0]
      if not table.contains(ident.value):
        ErrorHandler.error(200, "Unbound identifier: " + ident.value)
  return ast

class IR:
  var opcode as primative
  var operand as primative

  define constructor(op as primative, val as primative):
    opcode = op
    operand = val

  static define from_node(node as Node) as IR:
    when node.type == "VarDecl":
      return IR.new("MOV", node.children[1].value)
    when node.type == "ExprStmt":
      return IR.new("EVAL", node.children[0].value)
    ErrorHandler.error(300, "Unsupported node type: " + node.type)

define to_nasm(self as IR) as primative:
  when self.opcode == "MOV":
    return "mov eax, " + self.operand
  when self.opcode == "EVAL":
    return "call " + self.operand
  return "; unknown opcode"

define emit_binary(nasm_code as primative, output_path as primative):
  IO.write_file("temp.asm", nasm_code)
  __sys_run("nasm -f elf64 temp.asm -o temp.o")
  __sys_run("ld temp.o -o " + output_path)

define compile(source_path as primative, output_path as primative):
  val source = IO.read_file(source_path)
  val tokens = tokenize(source)
  val ast = parse(tokens)
  resolve_scopes(ast)
  bind(ast, SymbolTable.new())
  val ir_list = []
  for node in ast.nodes:
    ir_list.append(IR.from_node(node))
  val nasm_code = ""
  for ir in ir_list:
    nasm_code += ir.to_nasm() + "\n"
  emit_binary(nasm_code, output_path)

