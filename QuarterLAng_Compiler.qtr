# QuarterLang Compiler — Full End-to-End Implementation
# All modules in `.qtr` syntax, concatenated as separate sections.

# --- QuarterLang_MemoryHandler.qtr ---
star
  module MemoryHandler:
    # Basic heap management
    define allocate(size as primative) as pointer:
      # low-level allocation pseudocode
      val ptr as pointer = __sys_alloc(size)
      return ptr
    end define

    define free(ptr as pointer):
      __sys_free(ptr)
    end define

    define gc_collect():
      # mark-and-sweep pseudocode
      call mark_all_roots()
      call sweep_unmarked()
    end define
  end module
end

# --- QuarterLang_RangeAdjuster.qtr ---
star
  module RangeAdjuster:
    # Adjust numeric ranges
    define clamp(value as primative, min as primative, max as primative) as primative:
      when value < min:
        return min
      end when
      when value > max:
        return max
      end when
      return value
    end define

    define normalize(value as primative, in_min as primative, in_max as primative, out_min as primative, out_max as primative) as primative:
      val ratio as primative = (value - in_min) / (in_max - in_min)
      return out_min + ratio * (out_max - out_min)
    end define
  end module
end

# --- QuarterLang_ErrorHandler.qtr ---
star
  module ErrorHandler:
    # Centralized error reporting
    define error(code as primative, message as primative):
      __console_write("[Error " + code + "]: " + message)
      __sys_exit(code)
    end define

    define warn(message as primative):
      __console_write("[Warning]: " + message)
    end define

    define info(message as primative):
      __console_write("[Info]: " + message)
    end define
  end module
end

# --- QuarterLang_Indexter.qtr ---
star
  module Indexter:
    # Symbol indexing for AST
    define index_symbols(ast as AST) as SymbolTable:
      val table as SymbolTable = new SymbolTable()
      loop symbol in ast.symbols:
        table.add(symbol.name, symbol)
      end loop
      return table
    end define
  end module
end

# --- QuarterLang_IO.qtr ---
star
  module IO:
    # File and console I/O
    define read_file(path as primative) as primative:
      val content as primative = __sys_read_file(path)
      return content
    end define

    define write_file(path as primative, data as primative):
      __sys_write_file(path, data)
    end define

    define print(text as primative):
      __console_write(text)
    end define

    define println(text as primative):
      __console_write(text + "\n")
    end define
  end module
end

# --- QuarterLang_Filer.qtr ---
star
  module Filer:
    # Module manager for QuarterLang packages
    define load_module(name as primative) as Module:
      val path as primative = name + ".qtr"
      val src as primative = IO.read_file(path)
      return Parser.parse(src)
    end define
  end module
end

# --- QuarterLang_LibrarySystem.qtr ---
star
  module LibrarySystem:
    # Manage built-in libraries
    var libs as Map = {}  # name -> Module

    define register(name as primative, mod as Module):
      libs[name] = mod
    end define

    define get(name as primative) as Module:
      when libs.contains(name) is false:
        ErrorHandler.error(404, "Library not found: " + name)
      end when
      return libs[name]
    end define
  end module
end

# --- QuarterLang_Lexer.qtr ---
star
  module Lexer:
    # Tokenize source
    define lex(input as primative) as List<Token>:
      var tokens as List<Token> = []
      var idx as primative = 0
      while idx < input.length:
        # skipping whitespace
        when is_whitespace(input[idx]):
          idx = idx + 1
          continue
        end when
        # identifiers
        when is_alpha(input[idx]):
          val start as primative = idx
          while idx < input.length and is_alnum(input[idx]): idx = idx + 1 end while
          tokens.push(Token.new("IDENT", input.substring(start, idx)))
          continue
        end when
        # numbers
        when is_digit(input[idx]):
          val start as primative = idx
          while idx < input.length and is_digit(input[idx]): idx = idx + 1 end while
          tokens.push(Token.new("NUMBER", input.substring(start, idx)))
          continue
        end when
        # single-char tokens
        tokens.push(Token.new(input[idx], input[idx].toString()))
        idx = idx + 1
      end while
      return tokens
    end define
  end module
end

# --- QuarterLang_SyntaxHighlighter.qtr ---
star
  module SyntaxHighlighter:
    # Basic syntax coloring logic
    define highlight(tokens as List<Token>) as List<StyledToken>:
      var styled as List<StyledToken> = []
      for token in tokens:
        var style as primative = "plain"
        when token.type == "IDENT" and LibrarySystem.libs.contains(token.value):
          style = "keyword"
        end when
        styled.push(StyledToken.new(token, style))
      end for
      return styled
    end define
  end module
end

# --- QuarterLang_Formatter.qtr ---
star
  module Formatter:
    # Pretty-print AST back to code
    define format(ast as AST) as primative:
      var out as primative = ""
      for node in ast.nodes:
        out = out + node.to_source() + "\n"
      end for
      return out
    end define
  end module
end

# --- QuarterLang_Parser.qtr ---
star
  module Parser:
    # Recursive-descent parser
    define parse(src as primative) as AST:
      val tokens as List<Token> = Lexer.lex(src)
      val cursor as Cursor = Cursor.new(tokens)
      return parse_program(cursor)
    end define

    define parse_program(cur as Cursor) as AST:
      var nodes as List<Node> = []
      while not cur.eof():
        nodes.push(parse_statement(cur))
      end while
      return AST.new(nodes)
    end define

    define parse_statement(cur as Cursor) as Node:
      # stub: parse based on token
      val tok as Token = cur.peek()
      when tok.type == "IDENT":
        return parse_expression(cur)
      end when
      ErrorHandler.error(100, "Unexpected token: " + tok.value)
    end define
  end module
end

# --- QuarterLang_AST.qtr ---
star
  module AST:
    # AST data structure
    class AST:
      var nodes as List<Node>
      define constructor(n as List<Node]):
        nodes = n
      end define
    end class

    class Node:
      var type as primative
      var children as List<Node>
      define constructor(t as primative, c as List<Node]):
        type = t
        children = c
      end define

      define to_source() as primative:
        return type  # simplistic
      end define
    end class
  end module
end

# --- QuarterLang_IRBytecode.qtr ---
star
  module IRBytecode:
    # Generate IR
    define generate(ast as AST) as List<IR>:
      var irs as List<IR> = []
      for node in ast.nodes:
        irs.push(IR.from_node(node))
      end for
      return irs
    end define
  end module
end

# --- QuarterLang_Encapsulation.qtr ---
star
  module Encapsulation:
    # Manage code modules
    define wrap(module as Module) as primative:
      return "<module>" + module.to_string() + "</module>"
    end define
  end module
end

# --- QuarterLang_Scoper.qtr ---
star
  module Scoper:
    # Lexical scoping
    define resolve_scopes(ast as AST) as AST:
      # placeholder
      return ast
    end define
  end module
end

# --- QuarterLang_Binder.qtr ---
star
  module Binder:
    # Symbol binding
    define bind(ast as AST, table as SymbolTable) as AST:
      # placeholder
      return ast
    end define
  end module
end

# --- QuarterLang_Adapter.qtr ---
star
  module Adapter:
    # AST ↔ IR adaptation
    define adapt_to_ir(ast as AST) as List<IR>:
      return IRBytecode.generate(ast)
    end define
  end module
end

# --- QuarterLang_Composer.qtr ---
star
  module Composer:
    # Compose multiple IR streams
    define compose(list_of_irs as List<List<IR>>) as List<IR>:
      var out as List<IR> = []
      for irs in list_of_irs:
        out = out + irs
      end for
      return out
    end define
  end module
end

# --- QuarterLang_Seeder.qtr ---
star
  module Seeder:
    # Seed standard library code
    define seed_stdlib() as List<Module>:
      # return built-in modules
      return [LibrarySystem.get("core"), LibrarySystem.get("math")]
    end define
  end module
end

# --- QuarterLang_CodeGenerator.qtr ---
star
  module CodeGenerator:
    # Generate NASM text
    define generate_nasm(irs as List<IR>) as primative:
      var out as primative = "section .text\n"
      for ir in irs:
        out = out + ir.to_nasm() + "\n"
      end for
      return out
    end define
  end module
end

# --- QuarterLang_BinaryEmitter.qtr ---
star
  module BinaryEmitter:
    # Assemble NASM to binary
    define emit(bin as primative) as primative:
      # call external assembler
      __sys_run("nasm -f bin -o out.bin -")
      return __sys_read_file("out.bin")
    end define
  end module

