star
import "Prompt.qtr"
import "CommandProcessor.qtr"
import "Config.qtr"

func run_repl():
    Config.load_defaults()
    loop true:
        Prompt.display()
        val cmd: string = ask()
        CommandProcessor.route(cmd)
end

star

import "Prompt.qtr"
import "CommandProcessor.qtr"
import "Config.qtr"
import "UserSession.qtr"   # Assume user/session system from before

# ==== Core REPL Runner ====

# Tracks REPL state and command history
var repl_history as List[string] = []
var is_running as bool = true

# Initialize and run the REPL event loop
func run_repl() {
    # Load default configuration settings (themes, prompts, keybindings, etc.)
    Config.load_defaults()
    call log("info", "REPL started with default configuration.")

    # Display welcome message
    call print("Welcome to QuarterLang REPL! Type 'help' for commands, 'exit' to quit.")

    loop is_running {
        # Display the prompt (could be dynamic based on session/user)
        Prompt.display()

        # Async read user input line; blocks until input is given
        val cmd_line: string = ask()

        # Record command in history
        repl_history.push(cmd_line)

        # Process the command asynchronously
        try {
            CommandProcessor.route(cmd_line)
        } catch err {
            call print("[ERROR] {err}")
            call log("error", "REPL command error: {err}")
        }
    }

    # When loop ends, shutdown cleanup
    call print("Goodbye from QuarterLang REPL!")
    call log("info", "REPL session ended.")
}

# ==== Prompt Module (Prompt.qtr) ====

# Displays the prompt, which can be customized dynamically
func Prompt.display() {
    # Example: show username and current prompt symbol
    val user: string = "guest"
    val prompt_sym: string = Config.get("prompt_symbol", "â­‘")
    call print("{user}@QuarterLang {prompt_sym} ", no_newline=true)
}

# ==== Command Processor Module (CommandProcessor.qtr) ====

# Holds registered commands: command name â†’ handler function
var commands as Map[string, fn(string[])] = {}

# Registers a new command with its handler function
func CommandProcessor.register(cmd_name: string, handler: fn(string[])) {
    commands[cmd_name] = handler
    call log("info", "Command '{cmd_name}' registered.")
}

# Parses command line into tokens (split by spaces, handles quotes, etc.)
func CommandProcessor.parse(cmd_line: string) as string[] {
    # Basic split by space; extend for quoted args if needed
    return split(cmd_line, " ")
}

# Routes a raw command line string to its handler
func CommandProcessor.route(cmd_line: string) {
    val tokens: string[] = CommandProcessor.parse(cmd_line)
    when len(tokens) == 0 {
        return  # empty input
    }
    val cmd_name: string = tokens[0]
    val args: string[] = tokens[1:]

    when commands.contains(cmd_name) {
        # Call the registered handler with args
        commands[cmd_name](args)
    } else {
        call print("Unknown command '{cmd_name}'. Type 'help' for list.")
    }
}

# ==== Config Module (Config.qtr) ====

var config_map as Map[string, primative] = {}

# Load default configs
func Config.load_defaults() {
    config_map["prompt_symbol"] = "â­‘"
    config_map["theme"] = "dark"
    config_map["max_history"] = 100
    call log("info", "Default configuration loaded.")
}

# Get config by key, return default if missing
func Config.get(key: string, default_val: primative) as primative {
    when config_map.contains(key) {
        return config_map[key]
    } else {
        return default_val
    }
}

# Set config key-value
func Config.set(key: string, value: primative) {
    config_map[key] = value
    call log("info", "Config '{key}' set to '{value}'.")
}

# ==== Builtin Commands Registration ====

func register_builtin_commands() {
    # Help command prints available commands
    CommandProcessor.register("help", fn(args: string[]) {
        call print("Available commands:")
        for key in commands.keys() {
            call print("- {key}")
        }
    })

    # Exit command to quit REPL
    CommandProcessor.register("exit", fn(args: string[]) {
        call print("Exiting REPL...")
        is_running = false
    })

    # Echo command repeats input
    CommandProcessor.register("echo", fn(args: string[]) {
        val output = join(args, " ")
        call print(output)
    })

    # History command prints last commands
    CommandProcessor.register("history", fn(args: string[]) {
        val max_len: int = Config.get("max_history", 100)
        val start_idx = max(0, len(repl_history) - max_len)
        for i in range(start_idx, len(repl_history)) {
            call print("{i + 1}: {repl_history[i]}")
        }
    })

    # User session info
    CommandProcessor.register("user", fn(args: string[]) {
        when len(args) == 0 {
            call print("Usage: user <login|logout|list> [username]")
            return
        }
        val subcmd = args[0]
        when subcmd {
            "login" {
                when len(args) < 2 {
                    call print("Usage: user login <username>")
                    return
                }
                call UserSession.login(args[1])
            }
            "logout" {
                when len(args) < 2 {
                    call print("Usage: user logout <username>")
                    return
                }
                call UserSession.logout(args[1])
            }
            "list" {
                call UserSession.list_users()
            }
            else {
                call print("Unknown user subcommand '{subcmd}'")
            }
        }
    })
}

# ==== REPL Initialization ====

func initialize_repl() {
    register_builtin_commands()
    call log("info", "Builtin commands registered.")
}

# ==== Main Entry Point ====

func main() {
    initialize_repl()
    run_repl()
}

end

star

# Displays the REPL prompt with optional user and theme context

func display() {
    # Retrieve user from session if available, else default
    val user: string = "guest"
    # Attempt to get prompt symbol from config (fall back to default)
    val prompt_sym: string = Config.get("prompt_symbol", "â­‘")
    val theme: string = Config.get("theme", "dark")

    # Compose prompt string with theme/color coding (simplified)
    val prompt_str: string = when theme == "dark": "{user}@QLang {prompt_sym} " else: "{user}@QLang {prompt_sym} "

    # Print without newline, so input is on same line
    call print(prompt_str, no_newline=true)
}

end

star

# Map of commands: string â†’ function accepting string[] args
var commands as Map[string, fn(string[])] = {}

# Register a new command with a handler function
func register(cmd_name: string, handler: fn(string[])) {
    commands[cmd_name] = handler
    call log("info", "Registered command '{cmd_name}'.")
}

# Simple tokenizer/split for command line input (space separated)
func parse(cmd_line: string) as string[] {
    # This can be enhanced to support quoted strings later
    return split(cmd_line, " ")
}

# Routes a command line string to the appropriate handler
func route(cmd_line: string) {
    val tokens: string[] = parse(cmd_line)
    if len(tokens) == 0 {
        return  # empty input, no command
    }
    val cmd_name: string = tokens[0]
    val args: string[] = tokens[1..]  # from index 1 to end

    when commands.contains(cmd_name) {
        commands[cmd_name](args)
    } else {
        call print("Unknown command '{cmd_name}'. Type 'help' for a list.")
    }
}

end

star

var config_map as Map[string, primative] = {}

# Load default config values
func load_defaults() {
    config_map["prompt_symbol"] = "â­‘"
    config_map["theme"] = "dark"
    config_map["max_history"] = 100
    call log("info", "Configuration defaults loaded.")
}

# Get config value with fallback default
func get(key: string, default_val: primative) as primative {
    when config_map.contains(key) {
        return config_map[key]
    } else {
        return default_val
    }
}

# Set config key-value
func set(key: string, value: primative) {
    config_map[key] = value
    call log("info", "Config '{key}' set to '{value}'.")
}

end

star

var users as List[string] = []
var session_map as Map[string, Map[string, primative]] = {}  # username â†’ config map

# Generate a dummy UID for session signature
func generate_uid() as int {
    # Simple pseudo random based on timestamp (mock)
    return now() % 100000
}

# Convert int UID to symbolic DG string (mock)
func to_dg(uid: int) as string {
    # Simple hex string for demonstration
    return format("{:X}", uid)
}

# Login user: add to users list and initialize session config
func login(username: string) {
    when users.contains(username) {
        call print("User '{username}' already logged in.")
        return
    }
    users.push(username)
    session_map[username] = {
        "theme": "galactic",
        "prompt": "â­‘",
        "dg_sig": to_dg(generate_uid())
    }
    call print("ðŸ”“ Welcome, {username}!")
    call log("info", "User '{username}' logged in.")
}

# Logout user: remove from users list and session map
func logout(username: string) {
    when users.contains(username) {
        users.remove(username)
        session_map.remove(username)
        call print("ðŸ”’ Goodbye, {username}!")
        call log("info", "User '{username}' logged out.")
    } else {
        call print("User '{username}' is not logged in.")
    }
}

# List all logged-in users
func list_users() {
    when len(users) == 0 {
        call print("No users currently logged in.")
        return
    }
    call print("Logged in users:")
    for user in users {
        call print("- {user}")
    }
}

# Retrieve session config for user and key (returns empty string if missing)
func session_get_config(username: string, key: string) as string {
    when session_map.contains(username) and session_map[username].contains(key) {
        return session_map[username][key] as string
    } else {
        return ""
    }
}

end

func main_command_router(cmd: string):
  # First try plugin manager commands
  call PluginManager.handle_command(cmd)

  # Then route other commands...
  # CommandProcessor.route(cmd)
end func

star
import Parser
import Interpreter
import Codegen

module REPL:

  define start() as void:
    print("VACU REPL :: type 'exit' to quit")
    loop:
      print(">>> ", newline=false)
      val input = read_line()
      if input == "exit": break end if

      val ast = Parser.parse(input)
      print("AST: " + ast.to_string())

      val result = Interpreter.eval(ast)
      print("=> " + result.to_string())

      val bytecode = Codegen.emit(ast)
      print("Bytecode: " + bytecode.join(" | "))
    end loop
  end define

end module
end

star
module Node:
  record Number(value as Number)
  record String(value as String)
  record Identifier(name as String)
  record Binary(op as String, left as Node, right as Node)
  record Call(callee as Node, args as List<Node>)
  record VarDecl(name as String, value as Node)
  record VarAssign(name as String, value as Node)
  record FunctionDef(name as String, params as List<String>, body as List<Node>)
  record Block(statements as List<Node>)
  record Return(value as Node)
  record Import(module as String)
end module
end

star
module Interpreter:
  record Env(parent as Env?, vars as Map<String, Any>)

  define Env.new(parent as Env?) as Env:
    return Env(parent, {})
  end

  define Env.get(env as Env, key as String) as Any:
    if key in env.vars: return env.vars[key]
    elseif env.parent != nil: return get(env.parent, key)
    else: ErrorHandler.error(404, "Undefined variable: " + key)
  end

  define Env.set(env as Env, key as String, val as Any) as void:
    env.vars[key] = val
  end

  define eval(node as Node, env as Env) as Any:
    match node
      case Node.Number(n): return n
      case Node.String(s): return s
      case Node.Identifier(name): return Env.get(env, name)

      case Node.Binary(op, left, right):
        val l = eval(left, env)
        val r = eval(right, env)
        match op
          case "+": return l + r
          case "-": return l - r
          case "*": return l * r
          case "/": return l / r
        end match

      case Node.VarDecl(name, value):
        val v = eval(value, env)
        Env.set(env, name, v)
        return v

      case Node.VarAssign(name, value):
        val v = eval(value, env)
        Env.set(env, name, v)
        return v

      case Node.Call(callee, args):
        val fn = eval(callee, env)
        val argvals = args.map(x -> eval(x, env))
        return fn.apply(argvals)

      case Node.FunctionDef(name, params, body):
        val fn = lambda(args as List<Any>):
          val local = Env.new(env)
          for i = 0; i < params.length(); i += 1:
            Env.set(local, params[i], args[i])
          end for
          var result as Any
          for stmt in body:
            result = eval(stmt, local)
            if result isa Node.Return: return result.value
          end for
          return result
        end
        Env.set(env, name, fn)
        return fn

      case Node.Block(statements):
        var result as Any
        for stmt in statements:
          result = eval(stmt, env)
        end for
        return result

      case Node.Return(value):
        return eval(value, env)

      case Node.Import(module):
        val imported = Importer.load(module)
        for name, val in imported:
          Env.set(env, name, val)
        end for
        return nil
    end match
  end
end module
end

star
module Codegen:
  record VMState(reg as Map<String, Number>, mem as Map<String, Number>, pc as Number)

  define emit(node as Node, state as VMState) as List<String>:
    match node
      case Node.Number(n): return ["PUSH " + n.toString()]
      case Node.Identifier(name): return ["LOAD " + name]
      case Node.Binary(op, left, right):
        val code = []
        code += emit(left, state)
        code += emit(right, state)
        code += ["OP " + op]
        return code
      case Node.VarDecl(name, value):
        val code = emit(value, state)
        code += ["STORE " + name]
        return code
      case Node.FunctionDef(name, params, body):
        val label = "FUNC_" + name
        val bodycode = body.flatmap(stmt -> emit(stmt, state))
        return ["LABEL " + label] + bodycode + ["RET"]
    end match
  end
end module
end

star
module Importer:
  val registry as Map<String, Map<String, Any>> = {
    "math": {
      "pi": 3.14159,
      "square": lambda(xs): xs[0] * xs[0],
    }
  }

  define load(name as String) as Map<String, Any>:
    if name in registry: return registry[name]
    ErrorHandler.error(501, "Module not found: " + name)
  end
end module
end

star
module REPL:
  val global_env as Interpreter.Env = Interpreter.Env.new(nil)

  define run() as void:
    while true:
      print("> ", newline: false)
      val input = IO.read_line()
      val ast = Parser.parse(input)
      for stmt in ast.body:
        val result = Interpreter.eval(stmt, global_env)
        if result != nil: print("=> ", result)
      end for
    end while
  end
end module
end

module BytecodePrinter:
  define print_bytecode(code as list) as void:
    for i from 0 to len(code) - 1:
      val instr = code[i]
      print "[", i, "] ", instr.opcode, " ", join(instr.operands, ", ")
    end for
  end define
end module

module VMachine:
  struct Instruction:
    opcode as str
    operands as list
  end struct

  define run(code as list, env as dict) as primative:
    val ip = 0
    val stack = []
    val memory = env  # Shared symbol memory

    loop:
      when ip >= len(code): break end when
      val instr = code[ip]
      ip += 1

      match instr.opcode:
        case "PUSH":
          stack.append(instr.operands[0])
        case "LOAD":
          stack.append(memory[instr.operands[0]])
        case "STORE":
          memory[instr.operands[0]] = stack.pop()
        case "ADD":
          val b = stack.pop()
          val a = stack.pop()
          stack.append(a + b)
        case "SUB":
          val b = stack.pop()
          val a = stack.pop()
          stack.append(a - b)
        case "MUL":
          val b = stack.pop()
          val a = stack.pop()
          stack.append(a * b)
        case "DIV":
          val b = stack.pop()
          val a = stack.pop()
          stack.append(a / b)
        case "CALL":
          val func = memory[instr.operands[0]]
          val args = []
          for i from 0 to instr.operands[1] - 1:
            args.prepend(stack.pop())
          val result = func.call(args)
          stack.append(result)
        case "HALT":
          break
        default:
          error "Unknown opcode: ", instr.opcode
      end match
    end loop

    return stack.pop()
  end define
end module

module REPL:
  val global_env as dict = {}
  val history as list = []

  define repl_loop() as void:
    loop:
      print "\nðŸ” QuarterLang> ",
      val line = input()
      when line == "exit": break end when
      when line == "history":
        for i from 0 to len(history) - 1:
          print i, ": ", history[i]
        end for
        continue
      end when

      history.append(line)

      # Tokenize â†’ Parse â†’ Compile â†’ Run
      val ast = ExpressionParser.parse(line)
      val bytecode = Codegen.compile(ast)
      BytecodePrinter.print_bytecode(bytecode)
      val result = VMachine.run(bytecode, global_env)

      print "ðŸŸ¢ Result: ", result
    end loop

    save_history()
  end define

  define save_history() as void:
    val f = open("repl_history.txt", "w")
    for line in history: f.write(line + "\n") end for
    f.close()
  end define

  define load_history() as void:
    when exists("repl_history.txt"):
      val f = open("repl_history.txt", "r")
      while not f.eof():
        history.append(f.readline())
      end while
      f.close()
    end when
  end define
end module

# Session Start
REPL.load_history()
REPL.repl_loop()

module TypeChecker:

  type TypeEnv = Table of (String -> String)  # e.g., "x" -> "Number", "foo" -> "Function"

  define check(ast as ASTNode, env as TypeEnv) as String:
    match ast.kind:
      case "number":
        return "Number"
      case "identifier":
        return env.get(ast.name, "Unknown")
      case "binary":
        left = check(ast.left, env)
        right = check(ast.right, env)
        if left == "Number" and right == "Number":
          return "Number"
        else:
          error("Type mismatch in binary operation")
      case "call":
        func_type = check(ast.callee, env)
        if func_type != "Function":
          error("Trying to call non-function")
        return "Any"  # or look up function return type
      case "assign":
        val_type = check(ast.value, env)
        env[ast.name] = val_type
        return val_type
      case "function":
        env[ast.name] = "Function"
        return "Function"
    end match
  end define

end module

type Function = Struct(name, params, body, closure_env)

define make_function(name, params, body, env) as Function:
  return Function(name, params, body, clone(env))  # captured closure
end define

define call_function(fn as Function, args as List) as Value:
  env = clone(fn.closure_env)
  for i = 0 to len(fn.params):
    env[fn.params[i]] = args[i]
  end for
  return eval(fn.body, env)
end define

module Profiler:
  var instruction_count = Table()

  define track(op as String):
    instruction_count[op] = instruction_count.get(op, 0) + 1
  end define

  define report():
    print("Instruction Profile:")
    for k, v in instruction_count:
      print("  " + k + ": " + str(v))
    end for
  end define
end module

define execute(op as String):
  Profiler.track(op)
  ... # actual execution
end define

type Bytecode = Struct(code, source_map)  # code: List of Instr, source_map: IP â†’ Line

define emit(instr, line):
  bc.code.append(instr)
  bc.source_map[len(bc.code) - 1] = line
end define

define debug_trace(ip):
  line = bc.source_map.get(ip, -1)
  if line != -1:
    print("Executing line: " + str(line))
  end if
end define

module BinaryFormat:
  define save(bytecode as Bytecode, path as String):
    out = open(path, "wb")
    out.write(serialize(bytecode.code))
    out.write(serialize(bytecode.source_map))
    out.close()
  end define

  define load(path as String) as Bytecode:
    inp = open(path, "rb")
    code = deserialize(inp.read_chunk())
    smap = deserialize(inp.read_chunk())
    return Bytecode(code, smap)
  end define
end module

type Module = Struct(name, exports, bytecode)

module Linker:
  var modules = Table()

  define import(path as String) as Module:
    bc = BinaryFormat.load(path)
    name = infer_module_name(path)
    mod = Module(name, extract_exports(bc), bc)
    modules[name] = mod
    return mod
  end define

  define link(main_bc as Bytecode):
    for mod in modules:
      inject_into_main(main_bc, mod.bytecode)
    end for
  end define
end module

module REPL:
  var history = []
  var global_env = {}

  define loop():
    while true:
      line = input(">> ")
      history.append(line)
      ast = ExpressionParser.parse(line)
      TypeChecker.check(ast, global_env)
      bc = Codegen.compile(ast)
      VM.run(bc, global_env)
    end while
  end define

  define save_history(path):
    write(path, join(history, "\n"))
  end define

  define load_history(path):
    content = read(path)
    history = split(content, "\n")
    for line in history:
      ast = ExpressionParser.parse(line)
      bc = Codegen.compile(ast)
      VM.run(bc, global_env)
    end for
  end define
end module



